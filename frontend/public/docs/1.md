# Introduction

**Computation**: 

- Computation may or may not be purely arithmetic. To compute is to solve a problem, be it arithmetic or not. Chronologically, this was done by human beings followed by mechanical devices and now by electronic devices. Therefore, a computation is a type of calculation (arithmetic or not) that is well-defined.

> Note: Most of the definitions below may not make sense right now. The purpose of the introductory page is to give the reader a run-down of what will be covered in the following pages. Nevertheless, whatever isn’t understood will be covered in the following chapters.
> 

**Theory of Computation** mainly comprises of the following 3 sub-topics:

1. **Computability Theory:** Deals with the classification of problems which are computable and which aren’t.
    1. Computable Problems:
    2. Non-Computable Problems: 
2. **Automata Theory:** Dives into the mathematical model that can perform the required computation. The most powerful of these ‘mathematical computers’ is a Turing machine. For each varying formal grammar there exists a different Computational model that can describe that particular language. Formally, we define 4 different languages, namely:
    1. Recursively Enumerable Languages: Turing machines.
    2. Context Sensitive Languages: Linear Bounded Automata
    3. Context Free Languages: Pushdown Automata
    4. Regular Languages: Finite Automata
3. **Complexity Theory:** This is where we assess the efficiency of the above used mathematical model. Essentially, we classify problems according to their computational difficulty:
    1. P & NP problems
    2. NP Complete & NP Hard problems
    3. PSPACE & PSPACE Complete problems